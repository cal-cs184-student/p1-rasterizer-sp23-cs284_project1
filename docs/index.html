<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 284: Computer Graphics and Imaging, Spring 2023</h1>
<h1 align="middle">Project 1: Rasterizer</h1>
<h2 align="middle">I-Lun Tsai, Hsuan-Hao Wang, CS284-??</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>In this project, we built a rasterizer to draw simple triangles and colored them by interpolating colors from texture images using barycentric coordinates. 
  The final product was a functional vector graphics renderer that could render SVGs (Scalable Vector Graphics) as PNGs. We learned basic techniques such as 
  rasterizing triangles using different sampling rates or different texture mapping methods. Our main takeaway is getting familiar with the techniques used in 
  the rasterization pipeline and understanding the memory and computational tradeoffs between each method.</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/image1.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
      <td>
        <img src="images/image2.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/image3.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
      <td>
        <img src="images/image4.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
    </tr>
  </table>
</div>


<h3 align="middle">Part 2: Antialiasing triangles</h3>



<h3 align="middle">Part 3: Transforms</h3>

<p>We used the transform, translate, and rotate functions that we implemented to make a YMCABot out of a basic robot. We played around with the robot.svg file to get familiarized with which code segment corresponded to which body part. The hierarchal structure made it easy for us to move and rotate the robot’s entire arm without having to deal with the upper arm and lower arm. </p>


<h2 align="middle">Section II: Sampling</h2>

<p>We used the transform, translate, and rotate functions that we implemented to make a YMCABot out of a basic robot. We played around with the robot.svg file to get familiarized with which code segment corresponded to which body part. The hierarchal structure made it easy for us to move and rotate the robot’s entire arm without having to deal with the upper arm and lower arm. </p>

<h3 align="middle">Part 4: Barycentric coordinates</h3>

<p>Barycentric coordinates are a coordinate system for triangles, which specify the position of a point in a triangle with respect to its distances from the triangle's vertices. The barycentric coordinates of a point P in a triangle ABC are given by the ratios of the areas of sub-triangles PBC, PCA, and PAB to the area of triangle ABC. These ratios are often referred to as (alpha, beta, gamma), where </p>

<p>alpha = area of triangle PBC / area of triangle ABC <br> beta = area of triangle PCA / area of triangle ABC <br> gamma = area of triangle PAB / area of triangle ABC </p>

<p>The barycentric coordinates of P satisfy the condition alpha + beta + gamma = 1, and any point within and on the boundaries of the triangle can be represented by a unique set of barycentric coordinates.</p>

<p> Barycentric coordinates can also be used to smoothly blend colors in a triangle by performing color interpolation using the barycentric coordinates of each pixel inside the triangle. We describe a step-by-step approach below: </p>
<ol>
  <li>Assign a color (with RGB values 0-255) to each vertex of the triangle.</li>
  <li>For each pixel inside the triangle, compute its barycentric coordinates (alpha, beta, gamma) with respect to the triangle.</li>
  <li>Use the barycentric coordinates to linearly interpolate the colors at each vertex in RGB space  to obtain the color at the pixel.</li>
</ol>



<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>

<p>In texture mapping, pixel sampling refers to the process of determining the color or other attributes (e.g. opacity, roughness, geometry) of a surface at a specific point by sampling the texture that is to be applied to that surface. </p>
<p>To determine the texture at a particular point, we first calculated the barycentric coordinates for the pixel of interest, which is used to interpolate its corresponding location in the texture image using the provided corresponding texels of the triangle’s vertices. The texel coordinates we obtain from linear interpolation doesn’t always correspond with an exact texel in the texture image. Therefore, we use different sampling methods (e.g. nearest neighbor or bilinear interpolation) to determine the texel color. The texel color at that location in the texture image is then sampled to determine the texture color or other attributes to be applied at that point on the object's surface. </p>
<p>Different methods of sampling, such as nearest-pixel or bilinear sampling, can be used to smoothly blend between adjacent texels to create a more similar appearance to the texture image. </p>
<ul>
  <li>Nearest-pixel sampling takes the color from the nearest texel. In our implementation, we used the round() function to find the nearest integer values of the texel coordinates that were calculated from the pixel’s barycentric coordinates.</li>
  <li>Bilinear sampling weight the texel colors according to the distance of the texel of interest from the four nearest texels. The closer a point is to a particular texel, the more weight that texel’s color is given in the interpolation. This creates a smooth blend of color between adjacent pixels, resulting in a more similar appearance to the texture image. In our implementation, we used the lerp() function three times for each bilinear sample.</li>
</ul>


<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>

<p>We used the transform, translate, and rotate functions that we implemented to make a YMCABot out of a basic robot. We played around with the robot.svg file to get familiarized with which code segment corresponded to which body part. The hierarchal structure made it easy for us to move and rotate the robot’s entire arm without having to deal with the upper arm and lower arm. </p>



<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>

</body>
</html>
